// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: reactions.sql

package store

import (
	"context"
	"database/sql"
)

const createCommentReaction = `-- name: CreateCommentReaction :exec
INSERT INTO comment_reactions (comment_id, user_id, reaction)
VALUES ($1, $2, $3)
ON CONFLICT (comment_id, user_id)
DO UPDATE SET reaction = EXCLUDED.reaction
`

type CreateCommentReactionParams struct {
	CommentID int32
	UserID    int32
	Reaction  int16
}

func (q *Queries) CreateCommentReaction(ctx context.Context, arg CreateCommentReactionParams) error {
	_, err := q.db.ExecContext(ctx, createCommentReaction, arg.CommentID, arg.UserID, arg.Reaction)
	return err
}

const getAllCommentsWithReactions = `-- name: GetAllCommentsWithReactions :many
SELECT
    c.id,
    c.user_id,
    c.comment,
    c.created_at,
    COALESCE(SUM((CASE WHEN r.reaction = 1 THEN 1 ELSE 0 END)::int4), 0) AS likes,
    COALESCE(SUM((CASE WHEN r.reaction = -1 THEN 1 ELSE 0 END)::int4), 0) AS dislikes
FROM comments c
LEFT JOIN comment_reactions r ON r.comment_id = c.id
GROUP BY c.id
ORDER BY likes DESC, c.created_at DESC
`

type GetAllCommentsWithReactionsRow struct {
	ID        int32
	UserID    int32
	Comment   string
	CreatedAt sql.NullTime
	Likes     interface{}
	Dislikes  interface{}
}

func (q *Queries) GetAllCommentsWithReactions(ctx context.Context) ([]GetAllCommentsWithReactionsRow, error) {
	rows, err := q.db.QueryContext(ctx, getAllCommentsWithReactions)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAllCommentsWithReactionsRow
	for rows.Next() {
		var i GetAllCommentsWithReactionsRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Comment,
			&i.CreatedAt,
			&i.Likes,
			&i.Dislikes,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCommentReactionsCount = `-- name: GetCommentReactionsCount :one
SELECT
  COALESCE(SUM(CASE WHEN reaction = 1 THEN 1 ELSE 0 END), 0) AS likes,
  COALESCE(SUM(CASE WHEN reaction = -1 THEN 1 ELSE 0 END), 0) AS dislikes
FROM comment_reactions
WHERE comment_id = $1
`

type GetCommentReactionsCountRow struct {
	Likes    interface{}
	Dislikes interface{}
}

func (q *Queries) GetCommentReactionsCount(ctx context.Context, commentID int32) (GetCommentReactionsCountRow, error) {
	row := q.db.QueryRowContext(ctx, getCommentReactionsCount, commentID)
	var i GetCommentReactionsCountRow
	err := row.Scan(&i.Likes, &i.Dislikes)
	return i, err
}
